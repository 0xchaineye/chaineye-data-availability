# EIP 4844 的一些问答

## 1.什么是 Danksharding？

Danksharding 是为以太坊提出的新分片设计，与以前的设计相比，它引入了一些重要的简化。

自 2020 年以来所有最近的以太坊分片提案（包括 Danksharding 和 Danksharding 之前）与大多数非以太坊分片提案之间的主要区别是以太坊的以汇总为中心的路线图， 而不是为交易提供更多空间，以太坊分片为数据块提供更多空间，而以太坊协议本身并不试图解释这些数据。 验证 blob 只需要检查 blob 是否可用 - 它可以从网络下载。 这些 blob 中的数据空间预计将由支持高吞吐量事务的第 2 层汇总协议使用。

[![00](https://github.com/0xchaineye/chaineye-data-availability/blob/main/images/00.png)](https://github.com/savour-labs)


Danksharding 引入的主要创新（是合并的费用市场：在 Danksharding 中没有固定数量的分片，每个分片都有不同的块和不同的块提议者，只有 一个提议者选择进入该插槽的所有交易和所有数据。

为了避免这种设计对验证者提出高系统要求，我们引入了提议者/构建者分离（PBS）（称为区块构建者的一类特殊参与者竞标选择区块内容的权利 slot，提议者只需要选择出价最高的有效标头。 只有区块生成器需要处理整个区块（即使在那里，也可以使用第三方去中心化预言机协议来实现分布式区块生成器）； 所有其他验证者和用户都可以通过数据可用性采样非常有效地验证区块（请记住：区块的“大”部分只是数据）。


## 2.什么是 proto-danksharding（又名 EIP-4844）？

Proto-danksharding（又名 EIP-4844）是一项实施构成完整 Danksharding 规范的大部分逻辑和“脚手架”（例如交易格式、验证规则）的提案，但尚未实际实施任何分片。 在 proto-danksharding 实现中，所有验证者和用户仍然必须直接验证完整数据的可用性。

proto-danksharding 引入的主要特性是新的交易类型，我们称之为 blob-carrying 交易。 携带 blob 的事务与常规事务类似，只是它还携带称为 blob 的额外数据。 Blob 非常大 (~125 kB)，并且比类似数量的调用数据便宜得多。 但是，EVM 执行无法访问 blob 数据； EVM 只能查看对 blob 的承诺。

因为验证者和客户端仍然需要下载完整的 blob 内容，proto-danksharding 中的数据带宽目标是每个槽 1 MB，而不是完整的 16 MB。 然而，仍然有很大的可扩展性收益，因为该数据不会与现有以太坊交易的 gas 使用量竞争。


## 3.为什么向每个人都必须下载的块添加 1 MB 数据是可以的，而不只是让 calldata 便宜 10 倍？

这与平均负载和最坏情况负载之间的差异有关。 今天，我们已经遇到这样的情况，平均块大小约为 90 kB，但理论上最大可能的块大小（如果块中的所有 30M gas 都用于调用数据）约为 1.8 MB。 过去，以太坊网络处理的区块数量接近最大值。 然而，如果我们简单地将 calldata gas 成本降低 10 倍，那么虽然平均块大小会增加到仍然可以接受的水平，但最坏的情况会变成 18 MB，这对于以太坊网络来说太大了。

目前的 gas 定价方案无法将这两个因素分开：平均负载和最坏情况负载之间的比率取决于用户选择他们在 calldata 上花费多少 gas 与其他资源，这意味着 gas 价格必须是 基于最坏情况的可能性进行设置，导致平均负载不必要地低于系统可以处理的负载。 但是，如果我们改变 gas 定价以更明确地创建多维费用市场，我们可以避免平均情况/最坏情况负载不匹配，并在每个块中包含接近我们可以安全处理的最大数据量。 Proto-danksharding 和 EIP-4488 是两个完全这样做的提案。

|         |	Average case block size	 | Worst case block size|
|:-------:|:------------------------:|:--------------------|
|Status quo|        	85 kB	         |       1.8 MB        |
|EIP-4488	 | Unknown; 350 kB if 5x growth in calldata use	| 1.4 MB|
|Proto-danksharding	| 1 MB (tunable if desired)|	2 MB.   |


## 4.proto-danksharding (EIP-4844) 与 EIP-4488 相比如何？

EIP-4488 是解决相同平均情况/最坏情况负载不匹配问题的更早和更简单的尝试。 EIP-4488 使用两个简单的规则来做到这一点：

Calldata gas 成本从每字节 16 gas 降低到每字节 3 gas
每个块 1 MB 的限制加上每个事务额外的 300 字节（理论最大值：~1.4 MB）
硬限制是确保平均情况负载的较大增加不会导致最坏情况负载增加的最简单方法。 gas 成本的降低将大大增加 rollup 的使用，可能会将平均块大小增加到数百 KB，但硬限制将直接阻止单个块包含 10 MB 的最坏情况。 事实上，最坏情况下的块大小会比现在小（1.4 MB 对 1.8 MB）。

Proto-danksharding 相反创建了一个单独的交易类型，可以在大型固定大小的 blob 中保存更便宜的数据，每个块可以包含多少 blob。 这些 blob 不能从 EVM 访问（只有对 blob 的承诺可以），并且 blob 由共识层（信标链）而不是执行层存储。

EIP-4488 和 proto-danksharding 之间的主要实际区别在于，EIP-4488 试图将今天所需的更改降至最低，而 proto-danksharding 今天进行了大量更改，因此将来升级到完整分片所需的更改很少 . 尽管实现完全分片（使用数据可用性采样等）是一项复杂的任务，并且在 proto-danksharding 之后仍然是一项复杂的任务，但这种复杂性包含在共识层中。 一旦 proto-danksharding 推出，执行层客户端团队、rollup 开发人员和用户无需做进一步的工作即可完成向完全分片的过渡。 Proto-danksharding 还将 blob 数据与 calldata 分开，使客户端更容易在较短的时间内存储 blob 数据。

请注意，两者之间的选择不是非此即彼：我们可以很快实施 EIP-4488，然后在半年后使用 proto-danksharding 跟进。

## 5.proto-danksharding 实现了完整的 danksharding 的哪些部分，还有哪些有待实现？

引用 EIP-4844：

该 EIP 中已经完成的工作包括：

- 一种新的交易类型，其格式完全相同，需要存在于“全分片”中
- 全分片所需的所有执行层逻辑
- 全分片所需的所有执行/共识交叉验证逻辑
- BeaconBlock 验证和数据可用性采样 blob 之间的层分离
- 完整分片所需的大部分 BeaconBlock 逻辑
- blob 的自我调整的独立 gasprice。

要实现完全分片，还有待完成的工作包括：

- 共识层中 blob_kzgs 的低度扩展以允许 2D 采样
- 数据可用性采样的实际实现
- PBS（提议者/构建者分离），以避免要求单个验证者在一个时隙中处理 32 MB 的数据
- 每个验证器的保管证明或类似的协议内要求，以验证每个块中分片数据的特定部分

请注意，所有剩余的工作都是共识层更改，不需要执行客户端团队、用户或汇总开发人员的任何额外工作。


## 6.从所有这些非常大的块中爆炸的磁盘空间需求怎么样？

EIP-4488 和 proto-danksharding 都会导致每个插槽（12 秒）的长期最大使用量约为 1 MB。 这相当于每年约 2.5 TB，远高于以太坊今天所需的增长率。

在 EIP-4488 的情况下，解决这个问题需要历史过期（EIP-4444），客户端不再需要存储超过某个持续时间的历史（已提议从 1 个月到 1 年的持续时间）。

在 proto-danksharding 的情况下，共识层可以实现单独的逻辑来在一段时间后（例如 30 天）自动删除 blob 数据，无论是否实现了 EIP-4444。 但是，无论采用何种短期数据扩展解决方案，都强烈建议尽快实施 EIP-4444。

这两种策略都将共识客户端的额外磁盘负载限制在最多几百 GB。 从长远来看，采用一些历史过期机制本质上是强制性的：全分片每年会增加大约 40 TB 的历史 blob 数据，因此用户实际上只能存储其中的一小部分一段时间。 因此，值得尽快设定对此的期望。

## 7.如果数据在 30 天后被删除，用户将如何访问旧的 blob？

以太坊共识协议的目的并不是保证所有历史数据永远保存。 相反，目的是提供一个高度安全的实时公告板，并为其他去中心化协议留出空间来进行更长期的存储。 布告栏是为了确保布告栏上发布的数据有足够长的可用时间，以便任何需要该数据或任何备份数据的长期协议的用户都有足够的时间来获取数据并导入它 进入他们的其他应用程序或协议。

一般来说，长期的历史存储很容易。 虽然每年 2.5 TB 的容量对于常规节点来说太多了，但对于专用用户来说却很容易管理：您可以以每 TB 约 20 美元的价格购买非常大的硬盘驱动器，这在业余爱好者的能力范围内。 与具有 N/2-of-N 信任模型的共识不同，历史存储具有 1-of-N 信任模型：您只需要数据存储者之一是诚实的。 因此，每条历史数据只需要存储数百次，而不是实时共识验证的数千个节点的完整集合。

存储完整历史记录并使其易于访问的一些实用方法包括：

- 特定于应用程序的协议（例如汇总）可能要求其节点存储与其应用程序相关的历史部分。 历史数据丢失不会对协议造成风险，只会对单个应用程序造成风险，因此应用程序承担存储与自身相关的数据的负担是有意义的。
- 在 BitTorrent 中存储历史数据，例如。 每天自动生成和分发一个 7 GB 的文件，其中包含来自块的 blob 数据。
- 以太坊门户网络（目前正在开发中）可以很容易地扩展到存储历史记录。
- 区块浏览器、API 提供者和其他数据服务可能会存储完整的历史记录。
- 个人爱好者和进行数据分析的学者可能会存储完整的历史记录。 在后一种情况下，在本地存储历史为他们提供了重要的价值，因为它使得直接对其进行计算变得更加容易。
- TheGraph 等第三方索引协议可能会存储完整的历史记录。

在更高级别的历史存储（例如每年 500 TB）下，某些数据被遗忘的风险变得更高（此外，数据可用性验证系统变得更加紧张）。 这可能是分片区块链可扩展性的真正限制。 然而，目前所有提出的参数都远未达到这一点。


## 8.blob 数据的格式是什么？它是如何提交的？

一个 blob 是一个包含 4096 个字段元素的向量，数字在以下范围内：

0 <= x < 52435875175126190479447740508185965837690552500527637822603658699938581184513

blob 在数学上被视为表示具有上述模数的有限域上 < 4096 的多项式，其中域元素位于位置 i 在 blob 中是多项式的评估 ω^i, ω 是满足的常数 ω^4096 = 1

对 blob 的承诺是 KZG 对多项式承诺的散列。 然而，从实现的角度来看，关注多项式的数学细节并不重要。 相反，只会有一个椭圆曲线点的向量（基于拉格朗日的可信设置），而 KZG 对 blob 的承诺将只是一个线性组合。 引用 EIP-4844 中的代码：

```
def blob_to_kzg(blob: Vector[BLSFieldElement, 4096]) -> KZGCommitment:
    computed_kzg = bls.Z1
    for value, point_kzg in zip(tx.blob, KZG_SETUP_LAGRANGE):
        assert value < BLS_MODULUS
        computed_kzg = bls.add(
            computed_kzg,
            bls.multiply(point_kzg, value)
        )
    return computed_kzg
```

BLS_MODULUS 是上述模数，KZG_SETUP_LAGRANGE 是拉格朗日基可信设置的椭圆曲线点向量。 对于实施者来说，现在将其简单地视为黑盒专用哈希函数是合理的。


## 9.为什么直接使用KZG的hash而不是KZG？

EIP-4844 没有使用 KZG 直接表示 blob，而是使用版本哈希：单个 0x01 字节（表示版本）后跟 KZG 的 SHA256 哈希的最后 31 个字节。

这样做是为了 EVM 兼容性和未来兼容性：KZG 承诺是 48 字节，而 EVM 更自然地使用 32 字节值，如果我们从 KZG 切换到其他东西（例如，出于抗量子原因），承诺 可以继续是32字节。

## 10.proto-danksharding 中引入的两个预编译是什么？

Proto-danksharding 引入了两种预编译：blob 验证预编译和点评估预编译。

blob 验证预编译是不言自明的：它将版本化哈希和 blob 作为输入，并验证提供的版本化哈希实际上是 blob 的有效版本化哈希。 此预编译旨在供 optimistic rollups 使用。 引用 EIP-4844：

>> Optimistic rollups 只需要在提交欺诈证明时实际提供基础数据。 欺诈证明提交功能将要求将欺诈性 blob 的全部内容作为调用数据的一部分提交。 它将使用 blob 验证功能根据之前提交的版本化哈希验证数据，然后像今天一样对该数据执行欺诈证明验证。





























